// It's yet another iteration on top of Jeff's and Hubert's proposal (sent by Vijay on Friday July 24th, 8:10am CEDT): 
// https://docs.google.com/document/d/1ChF_yoO2nXU_MzOhH9JxP5FUIddTiEiZEym_7WMqUoE/edit

//
// Vijay B. (Microsoft), Dirk Balfanz (Google), Alexei Czeskis (Google), Jeff Hodges & Hubert Le Van Gong (PayPal)

// Rolf: notes for external Authenticator Protocol:
//
// 1 How could the FIDO Client/ASM know that the Authenticator doesn't support account selection?  Would the authenticator
//   generate an error when attempting to register a second account for same AppID?
// 2. How would the App know whether transaction confirmation is supported?  Would the OS (FIDO Client/ASM) display
//    the userPrompt instead if the authenticator doesn't have a display?
// 3. If we want the authenticator to perform account selection, it MUST get the AccountInfo
//    As a consequence, the external authenticator protocol needs to send that information to the authenticator!
//



// =====================================================================
// ========= Generic Web Challenge-Response Authentication API =========
// ========= High Level Definitions                            =========
// =====================================================================

partial interface Window {
    // A new DOM element from which all credential-related functions
    // are called
    readonly attribute Credentials credentials;
};


interface Credentials {
    // Used by RP during registration to mint a new credential
    Promise< Credential > makeCredential (
        // User-friendly information about the account for which the credential is being created
        AccountInfo accountInfo,    
        // Sequence of various acceptable credential generation
        // parameters for credentials that the RP is willing to
        // accept. These are ordered by RP preference.
        sequence< CredentialParameters > params,
        optional DOMString challenge = undefined
    );

    // Used during authentication to verify possession of an authenticator
    // Can be used in 2 ways:
    // (1) RP has no credential handles on hand (does not know who the user is)
    // -> RP does not specify any acceptableCredentials in filter
    // (2) RP has a specific credential handle(s) (knows who the user is)
    // -> RP specifies the acceptableTypes in filter
    // [vgb] Added defaults for optional parameters (for readability), condensed formal parameter name
    // [Rolf] GetAssertion is confusing as the attestation is also called assertion sometimes.  We should
    //        either call it SignAssertion/SignatureAssertion or just Signature.
    //        Note: we call the FIDO authentication key credential.  So returning a credentialInfo by a
    //              function called GetAssertion is confusing!
    //        Rename to promise< Assertion > getAssertion ( ... )
    promise< Assertion > getAssertion (
        DOMString challenge,
        optional CredentialFilter filter = {},
        optional SignatureParameters params = {}
    ); 
};


// FIDO abstraction is built on top of this below
dictionary CredentialParameters {
    // Indicates which type of credential should be made
    CredentialType type;
    
    // [vgb] Moved AccountInfo to the method, otherwise it gets repeated for each
    // [vgb] element in the sequence which seems pointless.
};


// FIDO abstraction is built on top of this below
dictionary SignatureParameters {
    // Prompt that can be shown to the user
    DOMString userPrompt;

    // More stuff here ...
};

// For use with window.credentials.GetAssertion()
// Note that a valid filter may not contain both
// acceptableCredentials and acceptableTypes. One or
// the other may be provided, but not both.
// [vgb] Changed this a bit to allow U2F primitive of "create if needed"
dictionary CredentialFilter {
    // Indicates which type of credentials may be used for
    // getting an assertion
    sequence< CredentialSpec > accept;
};

// [vgb] Generalized - the transport hints (which are FIDO-specific) are now in the FIDO part
// [Rolf] Why not calling it Assertion (or CryptoAssertion if Assertion is considered too generic)?
// [vgb] OK
interface Credential {
    // The type of credential this is
    readonly attribute CredentialType type,

    // An identifier for this credential (can be wrapped key)
    // [vgb] Renamed from handle for generality
    readonly attribute DOMString id;
};

// [vgb] New type needed to pass these on input to functions
// [vgb] Dictionaries are passed by value, interfaces by reference
// [vgb] So dictionaries are more appropriate as inputs to methods
// [Rolf] if only type XOR credentialID can be used, the type can't be required!
// [vgb] Type is always required, only the ID is optional.
// [vgb] Omitted ID means you don't care.
dictionary CredentialSpec {
    required CredentialType type;
    DOMString id;
};

// FIDO abstraction is built on top of this below
interface Signature {
};

interface Assertion {
    readonly attribute CredentialType type,
    readonly attribute DOMString id;
    readonly attribute Signature signature;
};

// [Rolf] if we want the authenticator to perform account selection, it MUST know this information!
//        As a consequence, the external authenticator protocol needs to send that information to the authenticator!
dictionary AccountInfo {
    // The RPs friendly display name
    // For example: "Google", "Facebook", "PayPal"
    // This is REQUIRED
    // [vgb] Adding required keyword. However, does there exist a potential for malicious RPs to masquerade as someone else?
    required DOMString rpDisplayName;

    // The RP knows how the user should be addressed
    // For example: "John P. Smith"
    // Note, authenticator should use localization APIs
    // (strong first heuristic) when displaying this
    // This is REQUIRED
    // [vgb] Adding required keyword.
    // [Rolf] Is the RP's view of the user's name (i.e. would it be used as "Dear <userDisplayName>" or 
    //        is this the user's preferred account name (e.g. "my business yahoo email")?
    required DOMString userDisplayName;

    // The user's account name
    // For example: john.p.smith@example.com
    // [Rolf]: Where would the "business" or "personal" be stored 
    // (i.e. the string to disambiguate different accounts of
    //  one user at the same RP?)
    DOMString accountName;

    // The user's account id
    // For example: 1098237235409872 or dXNlcmlk
    // [Rolf] What will the FIDO stack (in the OS) do with it?  Just pass-through?  Would we expect the RP to store a
        //        unique (at least per RP) account identifier in it?  If the user has multiple accounts at that RP
    //        would we expect it to be unique *only* in conjunction with accountName or even without?
    DOMString userId;

    // The URI that resolves to the user's account image
    // It could be a URL:
    // https://static.example.com/aJDB5qp/img.png
    // Or, it could be a data URI:
    // data:image/jpeg;base64,/9j/4AAQSkZJRgABAQE
    // [Rolf] Would the FIDO stack do anything with it (e.g. automatically retrieve URI in order to display image)?
    //        If yes: how would that work with the FIDO unlinkability goal (e.g. if URI=track.me/123455)?
        //        Or would we require WebOrigin(URI)==AppID?
    DOMString accountImageUri;
};


// ========================================================================
// ====== FIDO abstraction (built through inheritance of the above)  ======
// ========================================================================

// [Rolf] why not just "FIDO" (as opposed to "U2F" or "UAF")?
enum CredentialType {
    "FIDO_2_0"
};

// How to get in touch with the Authenticator holding the credential
enum TransportType {
    "Embedded",
    "USB",
    "NFC",
    "BT"
};

interface FIDOCredentialSpec : CredentialSpec {
    sequence< TransportType > transportHints;
}

//
// [1] 'interface FIDOSignature' is from fido-signature-format.html:
// 
// interface FIDOSignature {
//     readonly attribute DOMString clientData; 
//     readonly attribute DOMString authnrData; 
//     readonly attribute DOMString signature;
// };
// [vgb] Removed extraneous types. This is just a forward declaration to reference the other spec.
// [vgb] Also made attributes readonly in above comment, we should also do this in the signature format spec.
interface FIDOSignature : Signature;

// TODO: need forward declaration of AttestationStatement (as used in FIDOCredential)
// interface AttestationStatement {
//     readonly attribute AttestationInfo      attestationInfo;
//     readonly attribute DOMString            clientData;
//     readonly attribute TrustInfo            trustInfo;
//     readonly attribute AttestationSignature attSignature;
// };
interface AttestationStatement;

// for use with window.credentials.MakeCredential()
// [vgb] Removed knownCredentials since that use case seems to fit better in getAssertion
// [vgb] Switched to AlgorithmIdentifier to be consistent with the other structures below,
// [vgb] and because this allows us to reuse definitions from elsewhere. The same strings
// [vgb] "RS256" and "ES256" still work in this slot.
dictionary FIDOCredentialParameters : CredentialParameters {
    // Only use the specified algorithm
    AlgorithmIdentifier algorithm;

    // Only accept these types of authenticators
    sequence< AAGUID > authenticators;
    
    // If any of these credentials is present on an authenticator, then do not accept that authenticator
    sequence< CredentialSpec > exclude;
};

// [vgb] This typedef had gotten lost
typedef DOMString AAGUID;

// Returned after credential creation
// [vgb] Return the whole CredentialInfo instead of just the credentialID
// [Rolf] Why not calling it FIDORegistrationAssertion or FIDONewCredentialAssertion?
// [vgb] Done
// [vgb] Also made attestation optional for platforms that do not support it.
// [vgb] Also, for RPs that don't care about attestation, omitting the challenge in makeCredential
// [vgb] could tell the platform to leave out attestation which saves some time.
interface FIDOCredential : Credential {
    readonly attribute AlgorithmIdentifier algorithm;
    // Technical point: Web IDL does not allow an interface attribute to be a dictionary.
    // Since this will likely be sent over to a server in any case, we return the
    // public key as a serialized JsonWebKey dictionary.
    // An alternative is to define this as any and specify in text that a dictionary is returned.
    // However it seems like DOMString saves the author a step in the common case.
    readonly attribute DOMString publicKey;
        // will only be present if challenge was provided in makeCredential
    readonly attribute AttestationStatement? attestation;
    // Indicates which transport(s) this credential is currently available over
    // [vgb] Clarified that this is at a point in time, as transports may change
    // [vgb] Note that this is credential-level information, but transports are an authenticator property
    // [vgb] Credentials may move across authenticators (e.g. on a SIM card)
    readonly attribute sequence< TransportType > transportHints;
};